/*
   FALCON - The Falcon Programming Language.
   FILE: module_bitbuf.cpp

   Buffering extensions
   Main module entity
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Mon, 08 Jul 2013 13:22:03 +0200

   -------------------------------------------------------------------
   (C) Copyright 2013: the FALCON developers (see list in AUTHORS file)

   Licensed under the Falcon Programming Language License,
   Version 1.1 (the "License"); you may not use this file
   except in compliance with the License. You may obtain
   a copy of the License at

   http://www.falconpl.org/?page_id=license_1_1

   Unless required by applicable law or agreed to in writing,
   software distributed under the License is distributed on
   an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
   KIND, either express or implied. See the License for the
   specific language governing permissions and limitations
   under the License.

*/

#include <falcon/class.h>
#include <falcon/ov_names.h>
#include "bitbuf_ext.h"
#include "bitbuf_mod.h"
#include "buffererror.h"

#include "bitbuf_fm.h"

namespace Falcon {
namespace Feathers {

ModuleBitbuf::ModuleBitbuf():
         Module(FALCON_FEATHER_BITBUF_NAME, true)
{
   this->addConstant( "NATIVE_ENDIAN", (Falcon::int64)Falcon::Ext::BitBuf::e_endian_same );
   this->addConstant( "LITTLE_ENDIAN", (Falcon::int64)Falcon::Ext::BitBuf::e_endian_little );
   this->addConstant( "BIG_ENDIAN",    (Falcon::int64)Falcon::Ext::BitBuf::e_endian_big );
   this->addConstant( "REVERSE_ENDIAN",(Falcon::int64)Falcon::Ext::BitBuf::e_endian_reverse );

   Falcon::Class *bitbuf = Falcon::Ext::init_classbitbuf();

   this->addMantra( bitbuf, true );
   this->addMantra( new Falcon::Ext::ClassBitBufError, true );
}

ModuleBitbuf::~ModuleBitbuf()
{}

}
}


/*#
@module bitbuf Bit-orieted read/write buffer.
@ingroup feathers
@brief

This module provides a bit-precise stream-like growable memory buffer class
and support classes.

This is a rewrite of the Falcon 0.9 bufext feathers module.

@beginmodule feathers.bitbuf
*/


/*#
@class BitBuf
@brief Flexible memory buffer optimized for bit-precise binary mangling

The BitBuf class is a bit-precise stream-like growable memory buffer class.
It is designed to receive multiple writes efficiently and then to provide
an efficient random access to the written bits.

As long as the current
write position and data to be written are byte aligned, writes are performed
byte-wise (and so, very efficiently). The write performance may degrade when
there is the need to write a wide amount of data starting from an arbitrary
bit.

Data is written in a sequence of memory chunks that can be allocated in
a constant time. Adding more data doesn't require to grow and copy the
whole buffer.

Read and read/write pointer move operations cause a "consolidation", that
consists into writing all the data on a sequential memory area. This data
can be efficiently written when it's accessed byte-wise. Arbitrary bit
access and fetching of multiple bytes starting from an arbitrary bit
positions are much less efficient.

@note BitBuf can still receive new appended data after consolidation. When
subsequent read or pointer move operations are required, a new consolidation
will take place.

The BitBuf class provides support to write and read 8, 16, 32 and 64 bits
integers at from/to arbitrary bit positions in the stream. Also,
support for byte endian order transformation is provided.

\section BitBuf_clone Cloning

BitBuf class supports the @a BOM.clone operation; however, clone operations
cause consolidation of the source BitBuf.

\section BitBuf_stream Serialization

BitBuf class supports serialization via @a Storer. Once stored, the BitBuf
can be restored elsewhere, regenerating a BitBuf instance that can still
be written and enlarged.

\section BitBuf_sync Synchronization.

BitBuf provides a simple inner synchronization mutex that prevents
concurrent writes to break the buffer. However, it's necessary to use a
script level @a Shared resource (for instance, a @a Mutex) to coordinate
multiple writes that are to be seen atomically by the script.

*/


/*#
@class BufferError
@brief Error generated by buffer I/O related failures.
@optparam code A numeric error code.
@optparam description A textual description of the error code.
@optparam extra A descriptive message explaining the error conditions.
@from Error code, description, extra

*/

/* end of bitbuf_fm.cpp */
