/*
   FALCON - The Falcon Programming Language.
   FILE: collector.h

   Garbage collector
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Sun, 08 Feb 2009 16:08:50 +0100

   -------------------------------------------------------------------
   (C) Copyright 2009: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

#ifndef FALCON_COLLECTOR_H
#define FALCON_COLLECTOR_H

#include <falcon/setup.h>
#include <falcon/mt.h>
#include <falcon/string.h>
#include <falcon/enumerator.h>
#include <falcon/atomic.h>


namespace Falcon {

class GCToken;
class GCLock;
class Item;
class Class;
class VMContext;
class TextWriter;
class CollectorAlgorithm;
class Shared;

/** Falcon Garbage collector.

 @section coll_loop Collection mark-sweep loop thread.
 The mark-sweep loop has the follwing structure:
 - The items currently locked are marked.
 - The live modules are makred.
 - The VMs registered with this collector are scanned for live items to be marked.
 - The sweep loop reapes all the items that fall beyond the last live VM generation.
 - The new items are marked with the CURRENT generation, and moved in the normal garbage.
 - The generation is advanced.

   Items may be locked by active threads right after the first step, but they are
   allocated in the new item list; so, they cannot be reaped during the current loop.

 @section coll_trace History tracing

 The garbage collector provides a powerful debug feature called "history tracing".

 History tracing traces any operation performed by the GC on any pointer passed
 to it as a DeepData pointer, in particular creation, marking and destruction.
 The report includes taking timings and perform consistency checks. For instance,
 if the GC tries to create a pointer over another pointer that is not yet free,
 or if it tries to mark a pointer that has been already deleted, the program
 dies immediately tracing all the needed information via Engine::die.

 The tracing is useful not just to expose bugs in Falcon GC and engine memory
 management, but also to fix bugs generated by modules and embedding applications
 during the early development stages.

 For instance, suppose that an application misbehaves and destroys a DeepData
 that has ben delegated to Falcon. Then, the whole program will crash later on,
 when the GC tries to mark or destroy it; but using a C++ debugging device or
 an appropriate crash error handler, it is possible to get the history of the
 pointer that has caused the error and see where and when it was created, and
 approximately up to when it was still valid.

 Normally, history tracing is compiled in debug builds and disabled in
 release builds, but it is possible to
 compile it in release enabling the compilation option FALCON_TRACE_GC. Once
 compiled-in, the trace option can be enabled and disabled at any time. When
 disabled, it has just a small marginal cost with respect to the trace-free
 version, so it can stay compiled into any non time-critical application to
 be available for activation in case a deep diagniostic is needed.

 The history tracing is transparently enabled on any store() operator,
 using the FALCON_GC_STORE macro, which will be directed to the H_store operation
 when FALCON_TRACE_GC is enabled at compile-time. Then, to enable tracing the activity
 of the GC at runtime, the trace() method must be called.

 At that point, the tracing process becomes transparent.

 To get information about a single data pointer passed to the GC use the method
 getHistory(), while the whole status can be dumped using either dumpHistory() or
 enumerateHistory().

 \note The trace events are never removed until the the collector is destroyed,
 or until clearTrace() is explicitly called. This might cause an exponential
 growth in memory usage in large programs. Either be sure to periodically
 call clearTrace() or consider using traceMark() method to disable the tracing
 of GC mark calls.

*/

class FALCON_DYN_CLASS Collector
{

public:
   enum constants {
      MAX_GENERATION = 0xFFFFFFFE,
      SWEEP_GENERATION = 0xFFFFFFFF
   };

   /** What the GC should do */
   typedef enum {
      /** No action required */
      e_status_green,
      /** The GC is trying to collect memory on a by-opportunity basis */
      e_status_yellow,
      /** The GC is preempting contexts to obtain memory. */
      e_status_red
   } t_status;


   /** Base class for History Trace entries (ABC).
    Subclasses must reimplement the dump() method to have meaningful
    descriptions of events.

    */
   class HistoryEntry
   {
   public:
      /** Type of events.

       Subclasses must pick one of this types describing what kind
       of event they represent.
       */
      typedef enum tag_action_t {
         ea_create,
         ea_mark,
         ea_destroy
      } action_t;

      /** Kind of event that happened. */
      action_t m_action;

      /** Milliseconds since the program start when this event happend.
       */
      int64 m_ticks;

      virtual ~HistoryEntry();

      /** Returns a string representation of this entry.
       \return A string reprsenting this entry.
       */
      virtual String dump() const = 0;

   protected:
      /** Creates the entry.
         \param action The type of event
               (determining the type of subclass created here).
       */
      HistoryEntry( action_t action );

   };

   /** Entry representing a data creation in the History Trace.
    */
   class HECreate: public HistoryEntry
   {
   public:
      /** The file by which this entry was created. */
      String m_file;
      /** The line where this event was created. */
      int m_line;
      /** The name of the class that was associated with this data at DeepItem creation. */
      String m_class;

      /** Creates a creation event in the History Trace.
       \param file The file by which this entry was created.
       \param line The line in the given file where this event was created.
       \param The name of the class that was associated with this data at
               DeepItem creation.
       */
      HECreate( const String& file, int line, const String& className );
      virtual ~HECreate();

      virtual String dump() const;
   };

   /** Entry representing a data GC Mark in the History Trace.
    */
   class HEMark: public HistoryEntry
   {
   public:
      HEMark();
      virtual ~HEMark();

      virtual String dump() const;
   };

    /** Entry representing a data destruction in the History Trace.
    */
   class HEDestroy: public HistoryEntry
   {
   public:
      HEDestroy();
      virtual ~HEDestroy();

      virtual String dump() const;
   };

   /** Class representing the status of a data assigned to this collector.
    This is a container for the History Trace specific of a single data pointer.

    Also, it sotres some information about the current status of the given data,
    so that it is possible to immediately know about what the data is supposed
    to be and if it's still valid.
    */
   class DataStatus
   {
   public:
      /** Create the data status.
       Normally this constructor is called only by the owning collector
       after an H_store or H_storeLocked call.
       */
      DataStatus( void* data );
      ~DataStatus();

      /** The data that was delegated to the GC. */
      void* m_data;
      /** True if the data has been created and not yet destroyed. */
      bool m_bAlive;

      /** Adds an entry in the history list.
       \param e The new History Entry.
       */
      void addEntry( HistoryEntry* e );

      /** A String representation of this item and of all the associated history.
       \return a String representation of this entry.
       */
      String dump();

      typedef Enumerator<HistoryEntry> EntryEnumerator;

      /** Enumerates all the events in this status.
       \param r The enumerator that will receive the HistoryEntry items one at a time.

       Notice that the enumerator will receive an HistoryEntry reference, which
       might actually be a pointer to any one of the HistoryEntry subclasses.
       Use proper casting, if the virtual methods provided by the HistoryEntry
       hyerarcy is not enough.
       */

      void enumerateEntries( EntryEnumerator& r ) const;

   private:
      class Private;
      Private* _p;
   };


   /** Builds a memory pool.
      Initializes all element at 0 and set buffer sizes to the FALCON default.
   */
   Collector();

   /** Destroys all the items.
      Needless to say, this must be called outside any VM.
   */
   virtual ~Collector();

   /** Called upon creation of a new VM.
      This sets the current generation of the VM so that it is unique
      among the currently living VMs.
   */
   void registerContext( VMContext *ctx, Event* signalWhenDone = 0 );

   /** Called before destruction of a VM.
      Takes also care to disengage the VM from idle VM list.
   */
   void unregisterContext( VMContext *ctx );


   /*
   class ContextEnumerator {
   public:
      virtual ~ContextEnumerator(){}
      virtual void operator()(VMContext* ctx) = 0;
   };
   void enumerateContexts( ContextEnumerator& ectx );
*/

   /** Offers a context for inspection.
      \param ctx The context to be inspected.
   */
   void offerContext( VMContext* ctx );

   /** Starts the parallel garbage collector. */
   void start();

   /** Stops the collector.
      The function synchronously wait for the thread to exit and sets it to 0.
   */
   void stop();

   /**
   */
   bool setAlgorithm( int mode );
   int currentAlgorithm() const;
   CollectorAlgorithm* currentAlgorithmObject() const;

   /** Set item threshold for algorithm callback.
    * \param th The threshold level
    * \param doNow If true, and if the current level is already above the threshold,
    *    invoke the callback now.
    *
    * When the number of allocated item exceeds the given value,
    * the onItemThreshold callback method of the active algorithm is invoked.
    *
    */
   void itemThreshold( uint64 th, bool doNow = false );

   /** Set memory threshold for algorithm callback.
    * \param th The threshold level
    * \param doNow If true, and if the current level is already above the threshold,
    *    invoke the callback now.
    *
    * When the number of bytes exceeds the given value,
    * the onMemoryThreshold callback method of the active algorithm is invoked.
    */
   void memoryThreshold( uint64 th, bool doNow = false );

   /** Run a complete garbage collection.
    * \param wait True to wait for completion, false to return immediately.
    *
    * This method orders the GC to perform a complete garbage collection loop as soon as
    * possible, and then eventually waits for the completion of that loop.
    *
    */
   void performGC( bool wait = true );

   /** Run a complete garbage collection, and notify the given shared resource when done.
    * \param shared the shared resource to be signaled.
    *
    * This method orders the GC to perform a complete garbage collection loop as soon as
    * possible. When the reclaim loop is complete, the given shared resource is signaled.
    *
    */
   void performGCOnShared( Shared *shared );

   /** Stores an entity in the garbage collector.

    \note Use the macro FALCON_GC_STORE to transparently allow selecting
    this method or the H_store method depending on compilation options.
    Calling directly this method is to be considerated a deprecated practice.

     The entity gets stored in the new items, and will become reclaimable
     since the first scan loop that comes next.

     The data must be delivered to the garbage collection system with the
     class that describes it. The collector will call Class::gcmark to
     indicate that the item holding this object is alive. When the item
     is found dead, the collector will call Class::dispose to inform
     the class that the item is not needed by Falcon anymore.


     @param cls The class that manages the data.
     @param data An arbitrary data to be passed to the garbage collector.
     @return the token associated with this storage.
    */
   GCToken* store( const Class* cls, void* data );

   /** Stores an entity in the garbage collector and immediately locks it.

    \note Use the macro FALCON_GC_STORELOCKED to transparently allow selecting
    this method or the H_storeLocked method depending on compilation options.
    Calling directly this method is to be considerated a deprecated practice.

     This method stores an entity for garbage collecting, but adds an initial
     lock so that the collector cannot reclaim it, nor any other data depending
     from the stored entity.

     This is useful when the object is known to be needed by an external entity
     that may be destroyed separately from Falcon activity. A locked entity
     gets marked via Class::gcmark even if not referenced in any virtual machine,
     and gets disposed only if found unreferenced after the garbage lock is
     removed.

      @param cls The class that manages the data.
      @param data An arbitrary data to be passed to the garbage collector.
      @return A GCLock entity to control when the item becomes disposeable.
    */
   GCLock* storeLocked( const Class* cls, void* data );

   /** Locks an item.
    * @see GCLock
    */
   GCLock* lock( const Item& item );

   /** Unlocks a locked item.
    * \see GClock::dispose
    * */
   void unlock( GCLock* lock );

   /** Locks an item that is separately allocated in the heap.
    * @see GCLock
    */
   GCLock* lockPtr( Item* ptr );

   /**
    * Accounts for new or released memory.
    *
    * Use a negative number to remove allocated memory.
    */
   void accountMemory( int64 memory );
   /**
    * Current count of memory stored in the GC.
    *
    * This is estimated using the Class memory size information callback
    * to determine the size of instance as they're put in the GC, or
    * as the mark loops proceed.
    */
   int64 storedMemory() const;
   /**
    * Current count of items stored in the GC.
    */
   int64 storedItems() const;
   void stored( int64& memory, int64& items ) const;

   int64 activeMemory() const;
   int64 activeItems() const;
   void active( int64& memory, int64& items ) const;

   int64 sweepLoops( bool clear ) const;
   int64 markLoops( bool clear ) const;

   /**
    * Disable automatic garbage collection.
    * \param value true to disable automatic garbage collection.
    *
    * Setting the value to true prevent automatic item marking, causing garbage
    * memory not to be collected from that moment on.
    *
    * Explicit collection (e.g. performGC()) can still be performed.
    */
   void enable( bool value );

   /** Check if automatic collection is enabled.
    * \return true if the collection is enabled.
    */
   bool isEnabled() const;

   /** Returns current GC status.
    *
    */
   t_status status() const { return m_status; }

   /**
    * Changes the current GC status
    * \param s the new status.
    */
   void status( t_status s ) { m_status = s; }

   /** Check now if there is the need for a collection.
    *
    * Contrarily to performGC, mark/sweep is not forced and it is not
    * granted that the action, even in yellow or red state, collects
    * all the available memory.
    */
   void suggestGC();

   /** Callback the onTimeout method of the active algorithm after given time.
    * \param 0 to be called back after the given timeout, or 0 to disable.
    *
    * Calling this method multiple times cancels previous timeout callback.
    *
    */
   void algoTimeout( uint32 to );

#if FALCON_TRACE_GC
   /** Debug version of store.

      This specialization of store() saves an entry in the activity log of the
      garbage collector.

    Please refer to store() and to the class documentation for further details.

     @param cls The class that manages the data.
     @param data An arbitrary data to be passed to the garbage collector.
     @param file The file where the storage was done.
    @param line the line where the storage was done.
    @return the token associated with this storage.

    */
   GCToken* H_store( const Class* cls, void* data, const String& file, int line );

  /** DebugVersion of storeLocked().

   This specialization of storeLocked() saves an entry in the activity log of the
   garbage collector.

   Please refer to storeLocked() and to the class documentation for further details.

   @param cls The class that manages the data.
   @param data An arbitrary data to be passed to the garbage collector.
    @param file The file where the storage was done.
    @param line the line where the storage was done.
    @return A GCLock entity to control when the item becomes disposeable.

    */
   GCLock* H_storeLocked( const Class* cls, void* data, const String& file, int line );

   /** Returns true if activity tracing system is on.
    \return true if the tracing facility is active.
    \note this method is available only when FALCON_TRACE_GC macro is defined
    at compile time.
    */
   bool trace() const;

   /** Changes the tracing status of a collector.
      \param t True to enable tracing, false to disable it.

    Disabling and enabling tracing in a program at random spots may
    cause spurious critical error detection, or might miss serious errors,
    as the collector would not be able to determine if the event sequence
    is correct.

    It is advisable to enable and then eventually disable the tracing facility
    once per run at maximum.

    As marking and destroying untraced object is ignored, relevant errors involving
    objecsts created before the tracing option was enabled might go undetected.
    When in doubt, enable tracign since the beginning of the program, before
    doing anything else with Falcon engine. OTOH, when the source of problems
    is well identified (i.e. a module under testing), it is perfectly viable to
    enable tracing just before the problematic code section.

    \note Activating the trace through this method will also activate mark
    event tracing. If this is not desired, traceMark(false) must be invoked
    after each trace(true).

      \note this method is available only when FALCON_TRACE_GC macro is defined
    at compile time.

    */
   void trace( bool t );

   /** Returns true if activity tracing system is on -- relatively to the mark operation.
    \return true if the tracing facility is active.

    This method describes wether mark events are traced in the History Trace
    or not. Mark events are pretty numerous and they may grow the memory dedicated
    to tracing by many order of magnitudes, while the vital information is usually
    in the sequence of creation and destruction of items.

    However, even if the trace recording is disable, a formal check for the data
    pointer to be valid is always performed if trace() is active and traceMark()
    is disabled. Just, in this case the history of the various GC marking performed
    on the data is not recorded and cannot be inspected at a later time.

    \note this method is available only when FALCON_TRACE_GC macro is defined
    at compile time.
    */
   bool traceMark() const;

   /** Changes the tracing status of mark events in collector.
      \param t True to enable tracing, false to disable it.

       This method determines wether mark events are traced in the History Trace
    or not. Mark events are pretty numerous and they may grow the memory dedicated
    to tracing by many order of magnitudes, while the vital information is usually
    in the sequence of creation and destruction of items.

    However, even if the trace recording is disable, a formal check for the data
    pointer to be valid is always performed if trace() is active and traceMark()
    is disabled. Just, in this case the history of the various GC marking performed
    on the data is not recorded and cannot be inspected at a later time.

    Contrarily to trace(), this method may be invoked multiple times to activate
    and disactivate mark tracing at random in a program without compromising the
    validity of the checks that are performed.

      \note this method is available only when FALCON_TRACE_GC macro is defined
    at compile time.

    */
   void traceMark( bool t );


   /** Dumps all the history information on a selected device.
    \param target The TextWriter where to write the informaton.

    \note this method is available only when FALCON_TRACE_GC macro is defined
    at compile time.
    */
   void dumpHistory( TextWriter* target ) const;

   /** Enumeration receiving DataStatus entities.
    */
   typedef Enumerator<DataStatus> DataStatusEnumerator;

   /** Enumerates all the data-status.
    \param r The enumerator that will receive the DataStatus items one at a time.

    \note this method is available only when FALCON_TRACE_GC macro is defined
    at compile time.
    */
   void enumerateHistory( DataStatusEnumerator& r ) const;

   /** Gets the history of a single pointer that was delegated to the GC.
      \param pointer the data of which the history need to be known.
      \return A valid DataStatus entry or 0 if the pointer was never handled.

    The pointer in the parameter must be the address of a data that was passed
    to the H_store or H_storeLocked methods. Notice that it is possible that
    a destroyed data pointer was used more than once to hold different data
    (and even different data type); the history entries will then report
    multiple creation and destruction events. However, a creation event cannot
    follow another creation event if the pointer wasn't destroyed in the meanwhile,
    and similarly a destruction event cannot be followed by anything but another
    creation event.

    If the method returns 0, either the pointer was never seen by an H_* method
    or trace() was not active when the pointer was handled.

   \note this method is available only when FALCON_TRACE_GC macro is defined
    at compile time.

    */
   DataStatus* getHistory( const void* pointer ) const;

   /** Clears all the trace events recorded up to date.
    This destroys all the entries recored by the history tracing systems.

    New events on previously existing pointers will be ignored.

    \note this method is available only when FALCON_TRACE_GC macro is defined
    at compile time.

    */
   void clearTrace();




#endif

protected:
   class Cmd;

   /** Marker thread. */
   class FALCON_DYN_CLASS Marker: public Runnable {
   public:
      typedef enum {
         e_state_idle,
         e_state_disable,
         e_state_inspecting,
         e_state_marking,
         e_state_sweeping,
         e_state_terminated
      }
      t_state;

      typedef enum {
         e_mark_justmark,
         e_mark_check,
         e_mark_full
      }
      t_mark_mode;

      Marker( Collector* master ):
         m_master(master),
         m_state( e_state_idle ),
         m_mark_mode( e_mark_justmark ),
         m_bPendingDisable(false)
      {}
      virtual ~Marker(){}

      virtual void* run();

      t_state state() const { return m_state; }

   private:
      Collector* m_master;
      t_state m_state;
      t_mark_mode m_mark_mode;
      bool m_bPendingDisable;

      void performRegister(VMContext* m_ctx);
      void performUnregister(VMContext* m_ctx);
      void performOffer( VMContext* ctx);
      bool performMark( Cmd* cmd );
      bool performFull( Cmd* cmd );
      bool performCheck( Cmd* cmd );
      void performTerminate();

      bool performStartMark(Cmd* cmd);
      void performSweepComplete();

      void performEnable();
      void performDisable();

      void goToIdle();

      void rollover();
      void releaseContexts();

      void markLoop();
      void askMark();
   };

   /** Timer thread.
    * \note The timer thread could be eliminated if we created a collector per VM;
    * we could then use the VM scheduler for the purpose of being called back at intervals.
    * */
   class FALCON_DYN_CLASS Timer: public Runnable {
      public:
         Timer( Collector* master ):
            m_master(master)
         {}
         virtual ~Timer(){}

         virtual void* run();

      private:
         Collector* m_master;
      };

   /** Sweeper thread. */
   class FALCON_DYN_CLASS Sweeper: public Runnable {
   public:
      Sweeper( Collector* master ):
         m_master(master),
         m_lastSweepMark(0)
      {}
      virtual ~Sweeper(){}

      virtual void* run();

   private:
      void sweep( uint32 lastGen );

      void performFull();
      void performTerminate();
      Collector* m_master;
      uint32 m_lastSweepMark;
   };

   friend class Marker;
   friend class Sweeper;

   /** Alive and possibly collectible items are stored in this ring. */
   GCToken *m_garbageRoot;
   /** Mutex for m_garbageRoot */
   Mutex m_mtx_garbageRoot;

   /** Newly created, non-collectible items are stored in this ring. */
   GCToken *m_newRoot;
   /** Mutex for m_newRoot */
   mutable Mutex m_mtx_newRoot;


   /** A place where to store tokens for recycle. */
   GCToken *m_recycleTokens;
   int32 m_recycleTokensCount;
   Mutex m_mtx_recycle_tokens;

   /** The marker is in charge of marking incoming contexts */
   SysThread *m_thMarker;
   Marker m_marker;

   /** Timer thread, used for periodic memory checks by algorithms. */
   SysThread *m_thTimer;
   Timer m_timer;
   Event m_timerWork;
   Mutex m_mtx_timer;
   int64 m_algoRandezVous;

   /** The sweeper thread is in charge of killing unused memory */
   SysThread *m_thSweeper;
   Sweeper m_sweeper;

   /** The threads are stopped by turning this to off. */
   atomic_int m_aLive;

   /** Guard for ramp modes. */
   mutable Mutex m_mtx_algo;

   CollectorAlgorithm** m_algo;
   CollectorAlgorithm* m_curAlgoMode;
   int m_curAlgoID;


   /** Mutex for locked items ring. */
   Mutex m_mtx_lockitem;

   /** Locked and non reclaimable items are stored in this ring.  */
   GCLock *m_lockRoot;

   GCLock *m_recycleLock;
   int32 m_recycleLockCount;
   Mutex m_mtx_recycle_locks;

   //==================================================
   // Private functions
   //==================================================
   void onSweepBegin();
   void onSweepComplete( int64 freedMem, int64 freedItems );

   void clearRing( GCToken *ringRoot );

   void markLocked( uint32 mark );
   void disposeLock( GCLock* lock );
   void disposeToken(GCToken* token);

   void addGarbageLock( GCLock* lock );
   void removeGarbageLock( GCLock* lock );

   // Gets a new or pre-allocated token
   GCToken* getToken( Class* cls, void* data );

   // Marks the newly created items.
   void markNew( uint32 mark );

   // True to activate runtime trace.
   bool m_bTrace;
   bool m_bTraceMarks;

   // mark variables are associated with active contexts.
   // so they are locked with _p->m_mtx_context

   // mark currently used in mark loop, topmost mark
   Mutex m_mtx_currentMark;
   uint32 m_currentMark;

private:

   mutable Mutex m_mtx_history;

   void onCreate( const Class* cls, void* data, const String& file, int line );
   void onMark( void* data );
   void onDestroy( void* data );

   void store_internal( const Class* cls, void* data, GCToken* token );

   mutable Mutex m_mtx_accountmem;
   int64 m_storedMem;
   int64 m_storedItems;
   int64 m_aliveItems;
   int64 m_aliveMem;

   bool m_bEnabled;
   t_status m_status;

   uint64 m_memoryThreshold;
   uint64 m_itemThreshold;

   mutable uint64 m_markLoops;
   mutable uint64 m_sweepLoops;

   class Private;
   Private* _p;
};

}

#endif
/* end of collector.h */
